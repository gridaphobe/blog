<!DOCTYPE HTML>
<html><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><meta http-equiv="content-language" content="en"><meta name="author" content="Eric Seidel"><meta name="keywords" content="eric seidel,eric,seidel,eseidel,gridaphobe"><meta name="icon" href="/favicon.ico" type="image/x-icon"><title>On the Benefits of a Strong Type System</title><link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Eric Seidel"><link href="http://fonts.googleapis.com/css?family=Ubuntu|PT+Serif:400,700,400italic|Inconsolata" type="text/css" rel="stylesheet"><link href="/css/bootstrap.min.css" type="text/css" rel="stylesheet"><link href="/css/style.css" type="text/css" rel="stylesheet"><link href="/css/code.css" type="text/css" rel="stylesheet"></head><body><div class="container"><nav><ul class="breadcrumb"><li><a href="/">Home</a><span class="divider">|</span></li><li><a href="/posts">Archive</a><span class="divider">|</span></li><li><a href="//gridaphobe.github.io/">Projects</a><span class="divider">|</span></li><li><a href="/publications">Publications</a><span class="divider">|</span></li><li><a href="/cv.pdf">Resumé</a></li></ul></nav><section><h1>On the Benefits of a Strong Type System<small class="pull-right">Posted on June 21, 2012</small></h1><article><p>The other day I encountered a nasty bug (of my own making of course) at Fluidinfo, where I work part-time. At Fluidinfo we're trying to make the world writeable by allowing you to add bits of data, which we call Tags, to anything. So anyway, I wrote some code to remove a dataset I had imported last year that's taking up a lot of space but has no users. We use Python at Fluidinfo, so the code looked something like this</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tagIds <span class="op">=</span> <span class="co"># get the list of tags to delete</span>
store.find(TagValue, TagValue.<span class="bu">id</span> <span class="kw">in</span> tagIds).remove()</code></pre></div>
<p>That code is supposed to take a list of Tags and then remove all of their instances, simple enough right? Except of course that's not what it would have done, had I actually run it. The code would have removed all the tag-instances that shared an ID (in this case an Int as you might expect) with any of the Tag objects. That's bad, really bad... Particularly bad because it's entirely possible that the tag-instances that would have actually been deleted might not have been instances of the Tags I wanted to delete. What I <em>wanted</em> to say was</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tagIds <span class="op">=</span> <span class="co"># get the list of tags to delete</span>
store.find(TagValue, TagValue.tagId <span class="kw">in</span> tagIds).remove()</code></pre></div>
<p>Luckily my mistake was caught during code review and it was never executed! It could have easily slipped through though, only 3 characters differ between the correct line and disaster.</p>
<p>This incident got me thinking, how can we prevent mistakes like that from even reaching code review? In Python, as in many other dynamically-typed languages, the standard answer is unit tests. Make sure every path through the code is tested, and you can be substantially more confident that your code is correct. I won't argue that tests aren't important, but I'm not satisfied by that answer in this case. Why should I have to write a test for that? I can't think of a reasonable scenario where I would want to delete rows in a table because their primary key happened to be the same as the primary key of an item in a completely different table, can you?<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> I'd rather have the language come back and tell me that what I'm trying to do doesn't make the least bit of sense. Luckily some languages can do exactly that!</p>
<h2 id="enter-haskell">Enter Haskell</h2>
<p>Haskell is a pure functional language that I've been playing around with quite a bit lately. I even wrote my compiler for last semester's Compilers course in Haskell, which I might write about at some point. So how does Haskell help us solve my problem? Well, Haskell is strongly, statically typed, so I just define new types to represent <code>TagId</code>s and <code>TagValueId</code>s.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">TagId</span> <span class="fu">=</span> <span class="dt">TagId</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">TagValueId</span> <span class="fu">=</span> <span class="dt">TagValueId</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>If you're not familiar with Haskell, don't worry about the <code>deriving (Show)</code> bit, that just tells Haskell I'd like to be able to print these types out in the REPL. This post is a Literate Haskell file, so you can actually <a href="/posts/strong-type-systems.lhs">download it</a>, load it into <code>ghci</code> and play around if you feel so inclined. The important part is</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">TagId</span> <span class="fu">=</span> <span class="dt">TagId</span> <span class="dt">Int</span></code></pre></div>
<p>which just says that I'm creating a brand new type called <code>TagId</code>, and it's really just a wrapped-up integer. What does this buy me? Well, now the typechecker knows about two new types and will treat them as <strong>distinct</strong> from other integer-based types. Here's a simple function that operates on <code>TagId</code>s</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> nextTagId (<span class="dt">TagId</span> x) <span class="fu">=</span> <span class="dt">TagId</span> (x <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>Nothing too special here, we're just taking one <code>TagId</code> and returning a new one with the wrapped integer incremented, might be useful for assigning IDs to new Tags. Let's see how it works.</p>
<pre><code>ghci&gt; nextTagId (TagId 2)
TagId 3</code></pre>
<p>Who'd have thought?! What if I try to give it a plain old integer?</p>
<pre><code>ghci&gt; nextTagId 2

&lt;interactive&gt;:6:11:
    No instance for (Num TagId)
      arising from the literal `2&#39; ...</code></pre>
<p>Well this error message isn't that helpful, but it does tell us that a <code>TagId</code> cannot be used interchangably with an integer. Good to know, but not exaclty what we're here for. What if I pass in a <code>TagValueId</code>, which is implemented exactly like <code>TagId</code>?</p>
<pre><code>ghci&gt; nextTagId (TagValueId 2)

&lt;interactive&gt;:7:12:
    Couldn&#39;t match expected type `TagId&#39; with actual type `TagValueId&#39;
    In the return type of a call of `TagValueId&#39;
    In the first argument of `nextTagId&#39;, namely `(TagValueId 2)&#39;
    In the expression: nextTagId (TagValueId 2)</code></pre>
<p>Awesome! Not only does GHC tell us that we're not allowed to pass in a <code>TagValueId</code>, it also tells us that we probably meant to pass in a <code>TagId</code>. End of post, right? Not exactly...</p>
<h2 id="why-haskell">Why Haskell?</h2>
<p>By now you're probably wondering, &quot;What's so special about Haskell? I can do the same thing in Java or [insert strongly-, statically-typed language here].&quot; And you certainly can, here's an example of the <code>TagId</code> type in Java.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> TagId {
    <span class="fu">TagId</span>(<span class="dt">int</span> _i) { i = _i; }
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">getId</span>() { <span class="kw">return</span> i; }
    <span class="kw">private</span> <span class="dt">int</span> i;
}</code></pre></div>
<p>I could smugly point out that my Haskell code is a whole 4 lines shorter than the Java code, but let's face it, they both work just fine. So where's the difference?</p>
<p>You might not want to use the Java code because it boxes up the integer and allocates space on the heap, when you could have just used a primitive int. That seems like a trivial concern, but if you suddenly have to deal with millions of these <code>TagId</code>s, it could quickly become a real concern.</p>
<p>But wait, doesn't the Haskell code do the same thing? No, it does not. Here's the really cool thing about the <code>newtype</code> definition in Haskell. Since it is restricted to simple &quot;wrappers&quot; like a <code>TagId</code>, Haskell can actually prove that the <code>TagId</code> is never accidentally used as something else, and then throw away everything except the wrapped-up integer. Let me repeat that, <code>TagId</code> and <code>TagValueId</code> <strong>only exist at compile-time</strong>. At run-time they are both just integers, indistinguishable from one another, or any other &quot;primitive&quot; integer for that matter. But that's fine because the compiler has proved that we are using them correctly.</p>
<p>That's pretty damn cool if you ask me.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Some of you may rightly consider this hyperbole because you'd actually write a test to see if the code deleted the correct <code>TagValue</code>s. That's very true, but it's easy to construct a test-case that would give you a false positive: start with a fresh DB, create one Tag and one instance of that Tag. Both will have an ID of 1 and the test will pass, but not because the code is correct.<a href="#fnref1">↩</a></p></li>
</ol>
</section></article></section><footer class="footer"><p>Copyright &copy; Eric Seidel, 2012</p></footer></div></body></html>