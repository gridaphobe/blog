# Personal Blog

This repository contains the source code and content for my personal blog.
The blog is built using Haskell and the Stack toolchain. The static site files are generated into the `docs/` directory.

## Development Setup

This project is configured to use [Dev Containers](https://code.visualstudio.com/docs/devcontainers/containers) (compatible with VS Code and GitHub Codespaces) for a consistent and reproducible development environment.

1.  **Prerequisites:**
    *   Docker Desktop installed and running (if developing locally with VS Code).
    *   VS Code with the "Dev Containers" extension installed.
    *   Alternatively, open this repository in a GitHub Codespace.

2.  **Getting Started:**
    *   When you open this project in VS Code, you should be prompted to "Reopen in Container". Click it.
    *   If opening in GitHub Codespaces, the environment will be set up automatically.
    *   The first time the container builds, it will automatically run `stack build --only-dependencies` (due to the `postCreateCommand` in `.devcontainer/devcontainer.json`). This pre-builds all Haskell dependencies, so subsequent builds will be faster.

## Local Build Process

You can build the project and generate the blog content locally using either the provided `Makefile` or direct `stack` commands.

**Using `Makefile`:**

*   `make build`: Compiles the Haskell project.
*   `make generate`: Builds the project and then generates the blog's static files into the `docs/` directory. This is equivalent to `make all`.
*   `make all`: A convenient alias for `make generate`.
*   `make clean`: Removes Stack build artifacts (e.g., `.stack-work/`).

**Using direct `stack` commands:**

*   `stack build --only-dependencies`: Ensure all Haskell dependencies are built (usually done automatically by the dev container on startup).
*   `stack build`: Compile the project.
*   `stack run blog -- rebuild`: Generate the blog's static files. This command is specified in the `Makefile` for the `generate` target.

## Continuous Integration (CI)

This project uses GitHub Actions for Continuous Integration. The CI workflow is defined in `.github/workflows/ci.yml`.

*   **Triggers:** The CI workflow runs automatically on every push to the `main` branch and on every pull request targeting `main`.
*   **Checks:** It performs the following:
    1.  Sets up a Haskell/Stack environment.
    2.  Installs project dependencies (cached for speed).
    3.  Builds the Haskell project (`stack build`).
    4.  Generates the blog content (`stack run blog -- rebuild`).
*   **Purpose:** This ensures that changes integrate correctly and that the blog can always be built and generated. It's particularly important for validating automated dependency update pull requests.

## Automated Dependency Updates

To help keep the project up-to-date with minimal manual intervention, two automated dependency update mechanisms are in place:

1.  **Dependabot (`.github/dependabot.yml`):**
    *   **Scope:** Monitors for updates to:
        *   The Dev Container configuration (base Docker image, features in `.devcontainer/devcontainer.json`).
        *   GitHub Actions used in workflows (e.g., `actions/checkout`, `haskell-actions/setup`).
    *   **Schedule:** Checks for updates weekly.
    *   **Process:** If updates are found, Dependabot automatically creates a Pull Request (PR) with the suggested changes. These PRs are then tested by the CI workflow.

2.  **Scheduled Stackage LTS Update (`.github/workflows/update-lts.yml`):**
    *   **Scope:** Monitors for new Stackage Long-Term Support (LTS) snapshots for Haskell dependencies defined in `stack.yaml`.
    *   **Schedule:** Checks for updates weekly (currently configured for Monday at 00:00 UTC). Can also be triggered manually from the GitHub Actions tab.
    *   **Process:**
        *   If a newer LTS snapshot is found, the workflow attempts to update `stack.yaml`.
        *   It then tries to build the project and generate the blog with the new LTS.
        *   If successful, it creates a Pull Request with the updated `stack.yaml`. This PR is then also tested by the CI workflow.
    *   **Important:** The `update-lts.yml` workflow contains a condition `if: github.repository_owner == 'YOUR_GITHUB_USERNAME_OR_ORG'` which **must be updated** with your actual GitHub username or organization name to function correctly and prevent it from running on forks.

**Managing Automated PRs:**
Review Pull Requests generated by Dependabot and the LTS update workflow. If the CI checks pass and the changes look reasonable, merge them to keep your project's dependencies current.
