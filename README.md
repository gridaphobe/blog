# Personal Blog

This repository contains the source code and content for my personal blog.
The blog is built using Haskell and the Stack toolchain. The static site files are generated into the `docs/` directory.

## Development Setup

This project is configured to use [Dev Containers](https://code.visualstudio.com/docs/devcontainers/containers) (compatible with VS Code and GitHub Codespaces) for a consistent and reproducible development environment.

1.  **Prerequisites:**
    *   Docker Desktop installed and running (if developing locally with VS Code).
    *   VS Code with the "Dev Containers" extension installed.
    *   Alternatively, open this repository in a GitHub Codespace.

2.  **Getting Started:**
    *   When you open this project in VS Code, you should be prompted to "Reopen in Container". Click it.
    *   If opening in GitHub Codespaces, the environment will be set up automatically.
    *   The first time the container builds, it will automatically run `stack build --only-dependencies` (due to the `postCreateCommand` in `.devcontainer/devcontainer.json`). This pre-builds all Haskell dependencies, so subsequent builds will be faster.

## Local Build Process

You can build the project and generate the blog content locally using either the provided `Makefile` or direct `stack` commands.

**Using `Makefile`:**

*   `make build`: Compiles the Haskell project.
*   `make generate`: Builds the project and then generates the blog's static files into the `docs/` directory. This is equivalent to `make all`.
*   `make all`: A convenient alias for `make generate`.
*   `make clean`: Removes Stack build artifacts (e.g., `.stack-work/`).

**Using direct `stack` commands:**

*   `stack build --only-dependencies`: Ensure all Haskell dependencies are built (usually done automatically by the dev container on startup).
*   `stack build`: Compile the project.
*   `stack run blog -- rebuild`: Generate the blog's static files. This command is specified in the `Makefile` for the `generate` target.

## Continuous Integration (CI) and Deployment

This project uses GitHub Actions for Continuous Integration and automated deployment to GitHub Pages. The primary workflow for this is defined in `.github/workflows/ci.yml`.

*   **Triggers:** The workflow runs automatically on every push to the `master` branch and on every pull request targeting `master`.
*   **Build Job:**
    1.  Sets up a Haskell/Stack environment.
    2.  Installs project dependencies (cached for speed).
    3.  Builds the Haskell project (`stack build`).
    4.  Generates the blog content (`stack run blog -- rebuild`) into the `docs/` directory.
    5.  Uploads the content of the `docs/` directory as a GitHub Pages artifact.
*   **Deploy Job:**
    1.  Runs after the build job successfully completes.
    2.  Downloads the Pages artifact.
    3.  Deploys the artifact to GitHub Pages.
*   **Purpose:** This ensures that changes integrate correctly, the blog can always be built, and successful builds on the `master` branch are automatically deployed to GitHub Pages. It also validates automated dependency update pull requests.

## Automated Dependency Updates

To help keep the project up-to-date with minimal manual intervention, two automated dependency update mechanisms are in place:

1.  **Dependabot (`.github/dependabot.yml`):**
    *   **Scope:** Monitors for updates to:
        *   The Dev Container configuration (base Docker image, features in `.devcontainer/devcontainer.json`).
        *   GitHub Actions used in workflows (e.g., `actions/checkout`, `haskell-actions/setup`).
    *   **Schedule:** Checks for updates weekly.
    *   **Process:** If updates are found, Dependabot automatically creates a Pull Request (PR) with the suggested changes. These PRs are then tested by the CI workflow.

2.  **Scheduled Stackage LTS Update (`.github/workflows/update-lts.yml`):**
    *   **Scope:** Monitors for new Stackage Long-Term Support (LTS) snapshots for Haskell dependencies defined in `stack.yaml`.
    *   **Schedule:** Checks for updates weekly (currently configured for Monday at 00:00 UTC). Can also be triggered manually from the GitHub Actions tab.
    *   **Process:**
        *   If a newer LTS snapshot is found, the workflow attempts to update `stack.yaml`.
        *   It then tries to build the project and generate the blog with the new LTS.
        *   If successful, it creates a Pull Request with the updated `stack.yaml`. This PR is then also tested by the CI workflow.
    *   **Note:** The `update-lts.yml` workflow contains a condition `if: github.repository_owner == 'gridaphobe'` to ensure it runs correctly for this repository.

**Managing Automated PRs:**
Review Pull Requests generated by Dependabot and the LTS update workflow. If the CI checks pass and the changes look reasonable, merge them to keep your project's dependencies current.

### Configuring GitHub Pages Publishing Source

**Action Required:** After these workflow changes are merged, you **must** configure your GitHub repository to use GitHub Actions for deploying GitHub Pages.

1.  Navigate to your repository on GitHub.
2.  Go to **Settings** > **Pages**.
3.  Under "Build and deployment", change the **Source** from "Deploy from a branch" to **"GitHub Actions"**.

Once this setting is changed, pushes to the `master` branch will trigger the updated CI/CD workflow, which will automatically build and deploy your site to GitHub Pages.
